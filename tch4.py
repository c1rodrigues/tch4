# -*- coding: utf-8 -*-
"""
Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A0ndMgKNOn14sULlEfP8dslQ2gP6ncnF
"""

# Commented out IPython magic to ensure Python compatibility.
from sqlalchemy import create_engine
from sqlalchemy.engine.url import URL
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import plotly.express as px
import seaborn as sns
# %matplotlib inline

from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.stattools import acf, pacf
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.arima.model import ARIMA

from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error

import warnings
warnings.filterwarnings('ignore')
import streamlit as st

from prophet import Prophet

# Títulos
st.write("# Tech-Challenge")

# importando dados
df = pd.read_html('http://www.ipeadata.gov.br/ExibeSerie.aspx?module=m&serid=1650971490&oper=view', encoding='UTF-8', decimal=',', thousands='.')

df_petroleo = df[2]

df_petroleo.reset_index(drop=True, inplace=True)

new_header = ['data','preco_petroleo']
df_petroleo = df_petroleo[1:]
df_petroleo.columns = new_header

df_petroleo['data'] = pd.to_datetime(df_petroleo['data'])

df_petroleo['preco_petroleo'] =  df_petroleo['preco_petroleo'].astype(float)

df_petroleo.isnull().sum()

df_petroleo.info()

# criando abas na aplicação
tab0, tab1, tab2, tab3, tab4 = st.tabs(['pag1', 'pag2', 'pag3',
                                        'pag4', 'pag5'])

st.set_option('deprecation.showPyplotGlobalUse', False)


with tab0:

    df_petroleo[(df_petroleo['data'] >='2014-01-01') & (df_petroleo['data'] < '2024-01-01')]


    fig = px.line(df_petroleo, x = 'data', y = 'preco_petroleo', template='plotly_white')
    fig.update_layout( title="Evoluçaõ do Petróleo Brent",
        xaxis_title=" ",
        yaxis_title="Dolares por Barril")
    fig.show()
    
    """Primeira grande alta foi em Outubro de 1990. Essa alta se deu por conta da guerra entre Iraque e Kwait.
    
    A segunda grande alta se deu em Julho de 2008 devido a atrasos no potencial retorno do petróleo iraniano aos mercados globais e a considerações dos Estados Unidos e aliados europeus de proibir importações de petróleo russo.
    
    As negociações para reviver o acordo nuclear de 2015 do Irã com as potências mundiais produziram a queda do valor do barril do petróleo
    
    Em Outubro 2018 vemos uma queda brusca decorrente do assassinado do jornalista saudita Jamal Khashoggi, crítico do príncipe-herdeiro Mohamed bin Salman e exilado nos Estados Unidos.
    
    Depois disso temos a queda de Abril de 2020, decorrente do início da pandemia do COVID-19 e os dois picos de Março e Julho de 2022 decorrentes da Guerra entre Ucrânia e Rússia.
    """
    
    df_ajustado = df_petroleo.set_index('data', drop=True)
    
    df_ajustado
    
    resultados = seasonal_decompose(df_ajustado, period = 5, model='multiplicative')
    
    
    fig, (ax1, ax2, ax3, ax4) = plt.subplots(4,1, figsize = (15,10))
    
    resultados.observed.plot(ax=ax1)
    resultados.trend.plot(ax=ax2)
    resultados.seasonal.plot(ax=ax3)
    resultados.resid.plot(ax=ax4)
    
    plt.tight_layout()
with tab1:
    X  = df_ajustado.preco_petroleo.values
    
    result = adfuller(X)
    
    print("Teste ADF")
    print(f"Teste Estatístico: {result[0]}")
    print(f"P-Value: {result[1]}")
    print("Valores críticos:")
    
    for key, value in result[4].items():
      print(f"\t{key}: {value}")
    
    ma = df_ajustado.rolling(12).mean()
    
    
    f, ax = plt.subplots()
    df_ajustado.plot (ax=ax, legend = False)
    ma.plot (ax=ax, legend = False, color = 'r')
    
    
    plt.tight_layout()
    
    df_ajustado_log = np.log(df_ajustado)
    ma_log = df_ajustado_log.rolling(12).mean()
    
    f, ax = plt.subplots()
    df_ajustado_log.plot (ax=ax, legend = False)
    ma_log.plot (ax=ax, legend = False, color = 'r')
    
    
    plt.tight_layout()
    
    df_s = (df_ajustado_log - ma_log ).dropna()
    
    ma_s = df_s.rolling(12).mean()
    
    std = df_s.rolling(12).std()
    
    f, ax = plt.subplots()
    df_s.plot (ax=ax, legend = False)
    ma_s.plot (ax=ax, legend = False, color = 'r')
    std.plot (ax=ax, legend = False, color = 'g')
    
    plt.tight_layout()
    
    X_s  = df_s.preco_petroleo.values
    
    result_s = adfuller(X_s)
    
    print("Teste ADF")
    print(f"Teste Estatístico: {result_s[0]}")
    print(f"P-Value: {result_s[1]}")
    print("Valores críticos:")

with tab2:

    for key, value in result_s[4].items():
      print(f"\t{key}: {value}")
    
    df_diff = df_s.diff(1)
    ma_diff = df_diff.rolling(12).mean()
    
    std_diff = df_diff.rolling(12).std()
    
    f, ax = plt.subplots()
    df_diff.plot (ax=ax, legend = False)
    ma_diff.plot (ax=ax, legend = False, color = 'r')
    std_diff.plot (ax=ax, legend = False, color = 'g')
    
    plt.tight_layout()
    
    X_diff  = df_diff.preco_petroleo.dropna().values
    
    result_diff = adfuller(X_diff)
    
    print("Teste ADF")
    print(f"Teste Estatístico: {result_diff[0]}")
    print(f"P-Value: {result_diff[1]}")
    print("Valores críticos:")
    
    for key, value in result_diff[4].items():
      print(f"\t{key}: {value}")
    
    lag_acf = acf(df_diff.dropna(), nlags = 25)
    lag_pacf = pacf(df_diff.dropna(), nlags = 25)
    
    plt.plot(lag_acf)
    
    plt.axhline(y= -1.96/(np.sqrt((len(df_diff) -1))), linestyle = '--', color = 'gray', linewidth = .7)
    plt.axhline(y= 0, linestyle = '--', color = 'gray', linewidth = .7)
    plt.axhline(y= 1.96/(np.sqrt((len(df_diff) -1))), linestyle = '--', color = 'gray', linewidth = .7)
    
    plt.title("ACF")
    
    plt.show()
    
    plot_acf(df_ajustado.preco_petroleo)
    
    plt.show()
    
    plt.plot(lag_pacf)
    
    plt.axhline(y= -1.96/(np.sqrt((len(df_diff) -1))), linestyle = '--', color = 'gray', linewidth = .7)
    plt.axhline(y= 0, linestyle = '--', color = 'gray', linewidth = .7)
    plt.axhline(y= 1.96/(np.sqrt((len(df_diff) -1))), linestyle = '--', color = 'gray', linewidth = .7)
    
    plt.title("PACF")
    
    plt.show()

    plot_pacf(df_ajustado.preco_petroleo)
    
    plt.show()

with tab3:
    
    df = df_petroleo[(df_petroleo['data'] >'2014-01-01') & (df_petroleo['data'] <= '2024-01-01')]
    df = df.reset_index()
    df.drop(columns=['index'], inplace=True)
    # Renomeando as colunas para 'ds' e 'y'
    df = df.rename(columns={'data': 'ds', 'preco_petroleo': 'y'})
    #df[['ds','y']] = df[['data','preco_petroleo']]
    df.tail()
    
    #train_data = df.sample(frac=0.8, random_state=0)
    #test_data = df.drop(train_data.index)
    
    # Dividindo os dados em treinamento, validação e teste
    train_size = int(len(df) * 0.7)
    val_size = int(len(df) * 0.15)
    test_size = len(df) - train_size - val_size
    
    train_data, test_and_val_data = np.split(df, [train_size])
    val_data, test_data = np.split(test_and_val_data, [val_size])
    
    
    print(f'training data size : {train_data.shape}')
    print(f'testing data size : {test_data.shape}')
    
    train_data
    
    modelo = Prophet(daily_seasonality=True)
    modelo.fit(train_data)
    dataFramefuture = modelo.make_future_dataframe(periods=20, freq='M')
    previsao = modelo.predict(dataFramefuture)
    previsao.tail()
    
    modelo.plot(previsao, figsize=(20,6));
    plt.plot(test_and_val_data['ds'], test_and_val_data['y'], '.r')
    
    previsao_cols = ['ds', 'yhat']
    valores_reais_cols = ['ds', 'y']
    
    previsao = previsao[previsao_cols]
    valores_reais = test_and_val_data[valores_reais_cols]
    
    # Mesclar os DataFrames nas colunas 'ds' para comparar previsões e valores reais
    resultados = pd.merge(previsao, valores_reais, on='ds', how='inner')
    
    # Calcular o erro percentual absoluto para cada ponto de dados
    resultados['erro_percentual_absoluto'] = np.abs((resultados['y'] - resultados['yhat']) / resultados['y']) * 100
    
    # Calcular o MAPE
    mape = np.mean(resultados['erro_percentual_absoluto'])
    
    print(f"MAPE: {mape:.2f}%")

